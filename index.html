<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Word Search & Maze Generator</title>
        <!-- 1. Tailwind CSS for styling -->
        <script src="https://cdn.tailwindcss.com"></script>
        <!-- 2. jsPDF library for creating the PDF -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
        <!-- 3. JSZip library for creating .zip files -->
        <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
        <!-- 4. Inter font family -->
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap"
            rel="stylesheet"
        />
        <style>
            body {
                font-family: "Inter", sans-serif;
            }
            /* Custom style for number input arrows */
            input[type="number"]::-webkit-inner-spin-button,
            input[type="number"]::-webkit-outer-spin-button {
                -webkit-appearance: auto;
                opacity: 1;
                margin-left: 5px;
            }
        </style>
    </head>
    <body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
        <div class="bg-white p-8 rounded-lg shadow-xl max-w-2xl w-full">
            <h1 class="text-3xl font-bold text-center text-gray-800 mb-6">
                Word Search & Maze Generator
            </h1>

            <!-- Add Puzzle Form -->
            <div class="bg-gray-50 p-6 rounded-lg border border-gray-200 mb-6">
                <h2 class="text-xl font-semibold text-gray-700 mb-4">
                    Add Puzzle Batch
                </h2>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                    <div>
                        <label
                            for="puzzleType"
                            class="block text-sm font-medium text-gray-700"
                            >Puzzle Type</label
                        >
                        <select
                            id="puzzleType"
                            class="mt-1 w-full p-2 border border-gray-300 rounded-lg"
                        >
                            <option value="wordsearch">Word Search</option>
                            <option value="maze">Maze</option>
                        </select>
                    </div>
                    <div>
                        <label
                            for="gridSize"
                            class="block text-sm font-medium text-gray-700"
                            >Grid Size (10-50)</label
                        >
                        <input
                            type="number"
                            id="gridSize"
                            value="20"
                            min="10"
                            max="50"
                            class="mt-1 w-full p-2 border border-gray-300 rounded-lg"
                        />
                    </div>
                    <div>
                        <label
                            for="numPuzzles"
                            class="block text-sm font-medium text-gray-700"
                            >How many puzzles?</label
                        >
                        <input
                            type="number"
                            id="numPuzzles"
                            value="1"
                            min="1"
                            max="100"
                            class="mt-1 w-full p-2 border border-gray-300 rounded-lg"
                        />
                    </div>
                </div>
                <!-- Word Search Specific Options -->
                <div id="wordSearchOptions">
                    <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                        <div class="md:col-span-1">
                            <label
                                for="wordCount"
                                class="block text-sm font-medium text-gray-700"
                                >Word Count (1-100)</label
                            >
                            <input
                                type="number"
                                id="wordCount"
                                value="20"
                                min="1"
                                max="100"
                                class="mt-1 w-full p-2 border border-gray-300 rounded-lg"
                            />
                        </div>
                    </div>
                    <div>
                        <label
                            for="customWords"
                            class="block text-sm font-medium text-gray-700"
                            >Custom Words (Optional)</label
                        >
                        <textarea
                            id="customWords"
                            rows="3"
                            class="mt-1 w-full p-2 border border-gray-300 rounded-lg"
                            placeholder="Leave empty for random words. (One word per line or separated by spaces)"
                        ></textarea>
                    </div>
                </div>

                <button
                    id="addBatchBtn"
                    class="mt-4 w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition-all"
                >
                    Add Puzzle Batch
                </button>
            </div>

            <!-- Puzzle List -->
            <h3 class="text-lg font-semibold text-gray-600">
                Current Batches:
            </h3>
            <div
                id="batchList"
                class="mb-4 min-h-[40px] bg-gray-100 rounded-lg p-3 space-y-2"
            >
                <!-- Batches will be added here -->
            </div>

            <!-- Options -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4">
                <div>
                    <label
                        for="pageSize"
                        class="block text-sm font-medium text-gray-700"
                        >PDF Page Size</label
                    >
                    <select
                        id="pageSize"
                        class="mt-1 w-full p-2 border border-gray-300 rounded-lg"
                    >
                        <option value="a4">A4 (Default)</option>
                        <option value="letter">Letter</option>
                        <option value="legal">Legal</option>
                        <option value="tabloid">Tabloid</option>
                    </select>
                </div>
                <div class="flex items-center justify-center md:mt-6">
                    <input
                        type="checkbox"
                        id="generateImages"
                        class="h-4 w-4 text-blue-600 border-gray-300 rounded"
                    />
                    <label
                        for="generateImages"
                        class="ml-2 block text-sm font-medium text-gray-700"
                        >Generate as Images (ZIP)</label
                    >
                </div>
            </div>

            <!-- Total Counter -->
            <div class="text-center my-6">
                <strong class="text-lg"
                    >Total:
                    <span id="totalCount" class="text-blue-600">0</span
                    >/100</strong
                >
                <div id="remainingText" class="text-gray-600">
                    (<span id="remainingCount">100</span> remaining)
                </div>
                <button
                    id="clearBatches"
                    class="text-sm text-red-500 hover:text-red-700 underline mt-1"
                >
                    Clear All
                </button>
            </div>

            <!-- Generate Button -->
            <button
                id="generateBtn"
                class="w-full bg-blue-600 text-white font-bold px-6 py-3 rounded-lg shadow-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 transition-all duration-200 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed"
            >
                Generate
            </button>

            <!-- Status/Loading Message -->
            <div
                id="status"
                class="text-center text-gray-500 mt-6 min-h-[1.5em]"
            >
                <!-- Status messages will appear here -->
            </div>
        </div>

        <script>
            // --- CONFIGURATION ---
            const MAX_TOTAL_PUZZLES = 100;
            // All 8 directions: [rowChange, colChange]
            const DIRECTIONS = [
                [0, 1], // Horizontal (Right)
                [1, 0], // Vertical (Down)
                [1, 1], // Diagonal (Down-Right)
                [0, -1], // Horizontal (Left)
                [-1, 0], // Vertical (Up)
                [-1, -1], // Diagonal (Up-Left)
                [1, -1], // Diagonal (Down-Left)
                [-1, 1], // Diagonal (Up-Right)
            ];

            // --- DOM ELEMENTS ---
            const addBatchBtn = document.getElementById("addBatchBtn");
            const batchListEl = document.getElementById("batchList");
            const clearBatchesBtn = document.getElementById("clearBatches");

            const totalCountEl = document.getElementById("totalCount");
            const remainingCountEl = document.getElementById("remainingCount");
            const remainingTextEl = document.getElementById("remainingText");

            const pageSizeEl = document.getElementById("pageSize");
            const generateImagesEl = document.getElementById("generateImages");
            const generateBtn = document.getElementById("generateBtn");
            const statusEl = document.getElementById("status");

            // Form Inputs
            const puzzleTypeEl = document.getElementById("puzzleType");
            const gridSizeEl = document.getElementById("gridSize");
            const wordCountEl = document.getElementById("wordCount");
            const numPuzzlesEl = document.getElementById("numPuzzles");
            const customWordsEl = document.getElementById("customWords");
            const wordSearchOptionsEl =
                document.getElementById("wordSearchOptions");

            // --- STATE ---
            let puzzleRequests = [];

            // --- EVENT LISTENERS ---
            addBatchBtn.addEventListener("click", handleAddBatch);
            clearBatchesBtn.addEventListener("click", handleClearBatches);
            generateBtn.addEventListener("click", handleGenerateClick);
            customWordsEl.addEventListener("input", updateWordCountFromText);
            puzzleTypeEl.addEventListener("change", toggleWordSearchOptions);

            updateCounter();
            toggleWordSearchOptions(); // Call on load

            /**
             * Hides/shows word search options based on puzzle type
             */
            function toggleWordSearchOptions() {
                if (puzzleTypeEl.value === "maze") {
                    wordSearchOptionsEl.style.display = "none";
                } else {
                    wordSearchOptionsEl.style.display = "block";
                }
            }

            /**
             * Reads the custom words textarea and updates the word count
             */
            function updateWordCountFromText() {
                const rawWords = customWordsEl.value
                    .trim()
                    .split(/\s+/)
                    .filter((w) => w.length > 0);

                const sanitizedWords = rawWords
                    .map((w) => w.replace(/[^a-zA-Z]/g, "")) // Sanitize: remove non-letters
                    .filter((w) => w.length >= 3); // Filter by length *after* sanitizing

                if (rawWords.length > 0) {
                    wordCountEl.value = sanitizedWords.length; // Show the count of *valid* sanitized words
                    wordCountEl.disabled = true;
                } else {
                    wordCountEl.disabled = false;
                    wordCountEl.value = 20; // Reset to default if empty
                }
            }

            /**
             * Adds a new puzzle batch to the request list
             */
            function handleAddBatch() {
                const sanitizedCustomWords = customWordsEl.value
                    .trim()
                    .split(/\s+/)
                    .map((w) => w.replace(/[^a-zA-Z]/g, "")) // Sanitize
                    .filter((w) => w.length >= 3); // Filter for length >= 3

                const batch = {
                    puzzleType: puzzleTypeEl.value,
                    gridSize: parseInt(gridSizeEl.value, 10),
                    wordCount: parseInt(wordCountEl.value, 10),
                    numPuzzles: parseInt(numPuzzlesEl.value, 10), // <-- This line was missing
                    customWords: sanitizedCustomWords,
                    id: Date.now(), // Unique ID for removal
                };

                // Validation
                if (
                    isNaN(batch.gridSize) ||
                    batch.gridSize < 10 ||
                    batch.gridSize > 50
                ) {
                    setStatus("Grid size must be between 10 and 50.", "error");
                    return;
                }
                if (batch.puzzleType === "wordsearch") {
                    if (batch.customWords.length > 0) {
                        // If custom words are provided, use their count
                        batch.wordCount = batch.customWords.length;
                    }
                    if (
                        isNaN(batch.wordCount) ||
                        batch.wordCount < 1 ||
                        batch.wordCount > 100
                    ) {
                        setStatus(
                            "Word count must be between 1 and 100.",
                            "error",
                        );
                        return;
                    }
                } else {
                    batch.wordCount = 0; // Mazes have 0 words
                    batch.customWords = [];
                }
                if (
                    isNaN(batch.numPuzzles) ||
                    batch.numPuzzles < 1 ||
                    batch.numPuzzles > 100
                ) {
                    setStatus(
                        "Number of puzzles must be between 1 and 100.",
                        "error",
                    );
                    return;
                }
                if (
                    puzzleRequests.reduce((acc, b) => acc + b.numPuzzles, 0) +
                        batch.numPuzzles >
                    MAX_TOTAL_PUZZLES
                ) {
                    setStatus("Total puzzles cannot exceed 100.", "error");
                    return;
                }

                puzzleRequests.push(batch);
                updateBatchList();
                updateCounter();
                resetForm();
                setStatus("Batch added!", "success");
            }

            /**
             * Clears all added puzzle batches
             */
            function handleClearBatches() {
                puzzleRequests = [];
                updateBatchList();
                updateCounter();
            }

            /**
             * Resets the "Add Batch" form
             */
            function resetForm() {
                // Don't reset puzzle type
                gridSizeEl.value = 20;
                wordCountEl.value = 20;
                numPuzzlesEl.value = 1;
                customWordsEl.value = "";
                wordCountEl.disabled = false;
            }

            /**
             * Updates the visible list of added batches
             */
            function updateBatchList() {
                batchListEl.innerHTML = "";
                if (puzzleRequests.length === 0) {
                    batchListEl.innerHTML =
                        '<p class="text-gray-500 text-sm">No puzzle batches added yet.</p>';
                    return;
                }
                puzzleRequests.forEach((batch) => {
                    const el = document.createElement("div");
                    el.className =
                        "flex justify-between items-center bg-white p-2 rounded shadow-sm";

                    let typeDesc = "Unknown";
                    let wordDesc = "";

                    if (batch.puzzleType === "wordsearch") {
                        typeDesc = "Word Search";
                        if (batch.customWords.length > 0) {
                            wordDesc = `(${batch.customWords.length} custom words)`;
                        } else {
                            wordDesc = `(${batch.wordCount} random words)`;
                        }
                    } else if (batch.puzzleType === "maze") {
                        typeDesc = "Maze";
                        wordDesc = ""; // Mazes don't have words
                    }

                    el.innerHTML = `
                    <span class="text-gray-800">
                        ${batch.numPuzzles} x ${batch.gridSize}x${batch.gridSize} ${typeDesc}
                        <span class="text-gray-600 text-sm">${wordDesc}</span>
                    </span>
                    <button data-id="${batch.id}" class="remove-batch-btn text-red-500 hover:text-red-700 font-bold text-lg">&times;</button>
                `;
                    batchListEl.appendChild(el);
                });

                // Add event listeners to new remove buttons
                document
                    .querySelectorAll(".remove-batch-btn")
                    .forEach((btn) => {
                        btn.addEventListener("click", (e) => {
                            const idToRemove = parseInt(
                                e.target.dataset.id,
                                10,
                            );
                            puzzleRequests = puzzleRequests.filter(
                                (b) => b.id !== idToRemove,
                            );
                            updateBatchList();
                            updateCounter();
                        });
                    });
            }

            /**
             * Updates the total puzzle counter and button state
             */
            function updateCounter() {
                const total = puzzleRequests.reduce(
                    (acc, b) => acc + b.numPuzzles,
                    0,
                );
                const remaining = MAX_TOTAL_PUZZLES - total;

                totalCountEl.textContent = total;

                if (total > MAX_TOTAL_PUZZLES) {
                    remainingTextEl.textContent = `Too many! (${total - MAX_TOTAL_PUZZLES} over)`;
                    remainingTextEl.classList.add("text-red-600");
                    generateBtn.disabled = true;
                } else if (total === 0) {
                    remainingCountEl.textContent = remaining;
                    remainingTextEl.textContent = `(${remaining} remaining)`;
                    remainingTextEl.classList.remove("text-red-600");
                    generateBtn.disabled = true; // Don't generate 0 puzzles
                } else {
                    remainingCountEl.textContent = remaining;
                    remainingTextEl.textContent = `(${remaining} remaining)`;
                    remainingTextEl.classList.remove("text-red-600");
                    generateBtn.disabled = false;
                }
            }

            /**
             * Main function to handle the "Generate" button click
             */
            async function handleGenerateClick() {
                if (puzzleRequests.length === 0) {
                    setStatus("Please add at least one puzzle batch.", "error");
                    return;
                }

                const totalPuzzles = puzzleRequests.reduce(
                    (acc, b) => acc + b.numPuzzles,
                    0,
                );

                // Disable UI
                setLoadingState(true);
                setStatus("Generating... this may take a moment.", "loading");

                try {
                    // 1. Get all words
                    let totalRandomWords = 0;
                    puzzleRequests.forEach((batch) => {
                        if (
                            batch.puzzleType === "wordsearch" &&
                            batch.customWords.length === 0
                        ) {
                            totalRandomWords +=
                                batch.numPuzzles * batch.wordCount;
                        }
                    });

                    let randomWords = [];
                    if (totalRandomWords > 0) {
                        setStatus(
                            `Fetching ${totalRandomWords} random words...`,
                            "loading",
                        );
                        randomWords = await fetchWords(totalRandomWords);
                        if (!randomWords) return; // Error handled in fetchWords
                    }

                    const allPuzzles = [];
                    let randomWordIndex = 0;
                    let puzzleCounter = 0; // This will be the originalIndex

                    // 2. Generate each puzzle
                    for (const batch of puzzleRequests) {
                        for (let i = 0; i < batch.numPuzzles; i++) {
                            setStatus(
                                `Generating puzzle ${puzzleCounter + 1} of ${totalPuzzles} (${batch.gridSize}x${batch.gridSize})...`,
                                "loading",
                            );

                            let puzzleData = {};

                            if (batch.puzzleType === "wordsearch") {
                                let wordsForThisBatch = [];
                                if (batch.customWords.length > 0) {
                                    wordsForThisBatch = batch.customWords;
                                } else {
                                    wordsForThisBatch = randomWords.slice(
                                        randomWordIndex,
                                        randomWordIndex + batch.wordCount,
                                    );
                                    randomWordIndex += batch.wordCount;
                                }

                                if (
                                    wordsForThisBatch.length > batch.wordCount
                                ) {
                                    wordsForThisBatch = wordsForThisBatch.slice(
                                        0,
                                        batch.wordCount,
                                    );
                                }
                                puzzleData = generateWordSearch(
                                    wordsForThisBatch,
                                    batch.gridSize,
                                );
                            } else if (batch.puzzleType === "maze") {
                                puzzleData = generateMaze(batch.gridSize);
                            }

                            allPuzzles.push({
                                ...puzzleData,
                                puzzleType: batch.puzzleType,
                                gridSize: batch.gridSize,
                                wordCount: batch.wordCount, // Will be 0 for mazes
                                type: `${batch.gridSize}x${batch.gridSize} ${batch.puzzleType}`,
                                originalIndex: puzzleCounter, // Add the original 0-based index
                            });
                            puzzleCounter++;
                        }
                    }

                    // 3. Generate Output
                    if (generateImagesEl.checked) {
                        setStatus("Generating ZIP file...", "loading");
                        await generateZIP(allPuzzles);
                        setStatus("Success! Check your downloads.", "success");
                    } else {
                        setStatus("Compiling PDF...", "loading");
                        const pageSize = pageSizeEl.value;
                        await generatePDF(allPuzzles, pageSize);
                        setStatus("Success! Check your downloads.", "success");
                    }
                } catch (error) {
                    console.error("Error generating word searches:", error);
                    setStatus(`Error: ${error.message}`, "error");
                } finally {
                    // Re-enable UI
                    setLoadingState(false);
                }
            }

            // --- DICTIONARY & WORD FETCHING ---

            let _cachedDictionary = null;
            const dictionaryString = `
            a
abandon
ability
able
abortion
about
above
abroad
absence
absolute
absolutely
absorb
abuse
academic
accept
access
accident
accompany
accomplish
according
account
accurate
accuse
achieve
achievement
acid
acknowledge
acquire
across
act
action
active
activist
activity
actor
actress
actual
actually
ad
adapt
add
addition
additional
address
adequate
adjust
adjustment
administration
administrator
admire
admission
admit
adolescent
adopt
adult
advance
advanced
advantage
adventure
advertising
advice
advise
adviser
advocate
affair
affect
afford
afraid
African
African-American
after
afternoon
again
against
age
agency
agenda
agent
aggressive
ago
agree
agreement
agricultural
ah
ahead
aid
aide
AIDS
aim
air
aircraft
airline
airport
album
alcohol
alive
all
alliance
allow
ally
almost
alone
along
already
also
alter
alternative
although
always
AM
amazing
American
among
amount
analysis
analyst
analyze
ancient
and
anger
angle
angry
animal
anniversary
announce
annual
another
answer
anticipate
anxiety
any
anybody
anymore
anyone
anything
anyway
anywhere
apart
apartment
apparent
apparently
appeal
appear
appearance
apple
application
apply
appoint
appointment
appreciate
approach
appropriate
approval
approve
approximately
Arab
architect
area
argue
argument
arise
arm
armed
army
around
arrange
arrangement
arrest
arrival
arrive
art
article
artist
artistic
as
Asian
aside
ask
asleep
aspect
assault
assert
assess
assessment
asset
assign
assignment
assist
assistance
assistant
associate
association
assume
assumption
assure
at
athlete
athletic
atmosphere
attach
attack
attempt
attend
attention
attitude
attorney
attract
attractive
attribute
audience
author
authority
auto
available
average
avoid
award
aware
awareness
away
awful
baby
back
background
bad
badly
bag
bake
balance
ball
ban
band
bank
bar
barely
barrel
barrier
base
baseball
basic
basically
basis
basket
basketball
bathroom
battery
battle
be
beach
bean
bear
beat
beautiful
beauty
because
become
bed
bedroom
beer
before
begin
beginning
behavior
behind
being
belief
believe
bell
belong
below
belt
bench
bend
beneath
benefit
beside
besides
best
bet
better
between
beyond
Bible
big
bike
bill
billion
bind
biological
bird
birth
birthday
bit
bite
black
blade
blame
blanket
blind
block
blood
blow
blue
board
boat
body
bomb
bombing
bond
bone
book
boom
boot
border
born
borrow
boss
both
bother
bottle
bottom
boundary
bowl
box
boy
boyfriend
brain
branch
brand
bread
break
breakfast
breast
breath
breathe
brick
bridge
brief
briefly
bright
brilliant
bring
British
broad
broken
brother
brown
brush
buck
budget
build
building
bullet
bunch
burden
burn
bury
bus
business
busy
but
butter
button
buy
buyer
by
cabin
cabinet
cable
cake
calculate
call
camera
camp
campaign
campus
can
Canadian
cancer
candidate
cap
capability
capable
capacity
capital
captain
capture
car
carbon
card
care
career
careful
carefully
carrier
carry
case
cash
cast
cat
catch
category
Catholic
cause
ceiling
celebrate
celebration
celebrity
cell
center
central
century
CEO
ceremony
certain
certainly
chain
chair
chairman
challenge
chamber
champion
championship
chance
change
changing
channel
chapter
character
characteristic
characterize
charge
charity
chart
chase
cheap
check
cheek
cheese
chef
chemical
chest
chicken
chief
child
childhood
Chinese
chip
chocolate
choice
cholesterol
choose
Christian
Christmas
church
cigarette
circle
circumstance
cite
citizen
city
civil
civilian
claim
class
classic
classroom
clean
clear
clearly
client
climate
climb
clinic
clinical
clock
close
closely
closer
clothes
clothing
cloud
club
clue
cluster
coach
coal
coalition
coast
coat
code
coffee
cognitive
cold
collapse
colleague
collect
collection
collective
college
colonial
color
column
combination
combine
come
comedy
comfort
comfortable
command
commander
comment
commercial
commission
commit
commitment
committee
common
communicate
communication
community
company
compare
comparison
compete
competition
competitive
competitor
complain
complaint
complete
completely
complex
complicated
component
compose
composition
comprehensive
computer
concentrate
concentration
concept
concern
concerned
concert
conclude
conclusion
concrete
condition
conduct
conference
confidence
confident
confirm
conflict
confront
confusion
Congress
congressional
connect
connection
consciousness
consensus
consequence
conservative
consider
considerable
consideration
consist
consistent
constant
constantly
constitute
constitutional
construct
construction
consultant
consume
consumer
consumption
contact
contain
container
contemporary
content
contest
context
continue
continued
contract
contrast
contribute
contribution
control
controversial
controversy
convention
conventional
conversation
convert
conviction
convince
cook
cookie
cooking
cool
cooperation
cop
cope
copy
core
corn
corner
corporate
corporation
correct
correspondent
cost
cotton
couch
could
council
counselor
count
counter
country
county
couple
courage
course
court
cousin
cover
coverage
cow
crack
craft
crash
crazy
cream
create
creation
creative
creature
credit
crew
crime
criminal
crisis
criteria
critic
critical
criticism
criticize
crop
cross
crowd
crucial
cry
cultural
culture
cup
curious
current
currently
curriculum
custom
customer
cut
cycle
dad
daily
damage
dance
danger
dangerous
dare
dark
darkness
data
date
daughter
day
dead
deal
dealer
dear
death
debate
debt
decade
decide
decision
deck
declare
decline
decrease
deep
deeply
deer
defeat
defend
defendant
defense
defensive
deficit
define
definitely
definition
degree
delay
deliver
delivery
demand
democracy
Democrat
democratic
demonstrate
demonstration
deny
department
depend
dependent
depending
depict
depression
depth
deputy
derive
describe
description
desert
deserve
design
designer
desire
desk
desperate
despite
destroy
destruction
detail
detailed
detect
determine
develop
developing
development
device
devote
dialogue
die
diet
differ
difference
different
differently
difficult
difficulty
dig
digital
dimension
dining
dinner
direct
direction
directly
director
dirt
dirty
disability
disagree
disappear
disaster
discipline
discourse
discover
discovery
discrimination
discuss
discussion
disease
dish
dismiss
disorder
display
dispute
distance
distant
distinct
distinction
distinguish
distribute
distribution
district
diverse
diversity
divide
division
divorce
DNA
do
doctor
document
dog
domestic
dominant
dominate
door
double
doubt
down
downtown
dozen
draft
drag
drama
dramatic
dramatically
draw
drawing
dream
dress
drink
drive
driver
drop
drug
dry
due
during
dust
duty
each
eager
ear
early
earn
earnings
earth
ease
easily
east
eastern
easy
eat
economic
economics
economist
economy
edge
edition
editor
educate
education
educational
educator
effect
effective
effectively
efficiency
efficient
effort
egg
eight
either
elderly
elect
election
electric
electricity
electronic
element
elementary
eliminate
elite
else
elsewhere
e-mail
embrace
emerge
emergency
emission
emotion
emotional
emphasis
emphasize
employ
employee
employer
employment
empty
enable
encounter
encourage
end
enemy
energy
enforcement
engage
engine
engineer
engineering
English
enhance
enjoy
enormous
enough
ensure
enter
enterprise
entertainment
entire
entirely
entrance
entry
environment
environmental
episode
equal
equally
equipment
era
error
escape
especially
essay
essential
essentially
establish
establishment
estate
estimate
etc
ethics
ethnic
European
evaluate
evaluation
even
evening
event
eventually
ever
every
everybody
everyday
everyone
everything
everywhere
evidence
evolution
evolve
exact
exactly
examination
examine
example
exceed
excellent
except
exception
exchange
exciting
executive
exercise
exhibit
exhibition
exist
existence
existing
expand
expansion
expect
expectation
expense
expensive
experience
experiment
expert
explain
explanation
explode
explore
explosion
expose
exposure
express
expression
extend
extension
extensive
extent
external
extra
extraordinary
extreme
extremely
eye
fabric
face
facility
fact
factor
factory
faculty
fade
fail
failure
fair
fairly
faith
fall
false
familiar
family
famous
fan
fantasy
far
farm
farmer
fashion
fast
fat
fate
father
fault
favor
favorite
fear
feature
federal
fee
feed
feel
feeling
fellow
female
fence
few
fewer
fiber
fiction
field
fifteen
fifth
fifty
fight
fighter
fighting
figure
file
fill
film
final
finally
finance
financial
find
finding
fine
finger
finish
fire
firm
first
fish
fishing
fit
fitness
five
fix
flag
flame
flat
flavor
flee
flesh
flight
float
floor
flow
flower
fly
focus
folk
follow
following
food
foot
football
for
force
foreign
forest
forever
forget
form
formal
formation
former
formula
forth
fortune
forward
found
foundation
founder
four
fourth
frame
framework
free
freedom
freeze
French
frequency
frequent
frequently
fresh
friend
friendly
friendship
from
front
fruit
frustration
fuel
full
fully
fun
function
fund
fundamental
funding
funeral
funny
furniture
furthermore
future
gain
galaxy
gallery
game
gang
gap
garage
garden
garlic
gas
gate
gather
gay
gaze
gear
gender
gene
general
generally
generate
generation
genetic
gentleman
gently
German
gesture
get
ghost
giant
gift
gifted
girl
girlfriend
give
given
glad
glance
glass
global
glove
go
goal
God
gold
golden
golf
good
government
governor
grab
grade
gradually
graduate
grain
grand
grandfather
grandmother
grant
grass
grave
gray
great
greatest
green
grocery
ground
group
grow
growing
growth
guarantee
guard
guess
guest
guide
guideline
guilty
gun
guy
habit
habitat
hair
half
hall
hand
handful
handle
hang
happen
happy
hard
hardly
hat
hate
have
he
head
headline
headquarters
health
healthy
hear
hearing
heart
heat
heaven
heavily
heavy
heel
height
helicopter
hell
hello
help
helpful
her
here
heritage
hero
herself
hey
hi
hide
high
highlight
highly
highway
hill
him
himself
hip
hire
his
historian
historic
historical
history
hit
hold
hole
holiday
holy
home
homeless
honest
honey
honor
hope
horizon
horror
horse
hospital
host
hot
hotel
hour
house
household
housing
how
however
huge
human
humor
hundred
hungry
hunter
hunting
hurt
husband
hypothesis
I
ice
idea
ideal
identification
identify
identity
ie
if
ignore
ill
illegal
illness
illustrate
image
imagination
imagine
immediate
immediately
immigrant
immigration
impact
implement
implication
imply
importance
important
impose
impossible
impress
impression
impressive
improve
improvement
in
incentive
incident
include
including
income
incorporate
increase
increased
increasing
increasingly
incredible
indeed
independence
independent
index
Indian
indicate
indication
individual
industrial
industry
infant
infection
inflation
influence
inform
information
ingredient
initial
initially
initiative
injury
inner
innocent
inquiry
inside
insight
insist
inspire
install
instance
instead
institution
institutional
instruction
instructor
instrument
insurance
intellectual
intelligence
intend
intense
intensity
intention
interaction
interest
interested
interesting
internal
international
Internet
interpret
interpretation
intervention
interview
into
introduce
introduction
invasion
invest
investigate
investigation
investigator
investment
investor
invite
involve
involved
involvement
Iraqi
Irish
iron
Islamic
island
Israeli
issue
it
Italian
item
its
itself
jacket
jail
Japanese
jet
Jew
Jewish
job
join
joint
joke
journal
journalist
journey
joy
judge
judgment
juice
jump
junior
jury
just
justice
justify
keep
key
kick
kid
kill
killer
killing
kind
king
kiss
kitchen
knee
knife
knock
know
knowledge
lab
label
labor
laboratory
lack
lady
lake
land
landscape
language
lap
large
largely
last
late
later
Latin
latter
laugh
launch
law
lawn
lawsuit
lawyer
lay
layer
lead
leader
leadership
leading
leaf
league
lean
learn
learning
least
leather
leave
left
leg
legacy
legal
legend
legislation
legitimate
lemon
length
less
lesson
let
letter
level
liberal
library
license
lie
life
lifestyle
lifetime
lift
light
like
likely
limit
limitation
limited
line
link
lip
list
listen
literally
literary
literature
little
live
living
load
loan
local
locate
location
lock
long
long-term
look
loose
lose
loss
lost
lot
lots
loud
love
lovely
lover
low
lower
luck
lucky
lunch
lung
machine
mad
magazine
mail
main
mainly
maintain
maintenance
major
majority
make
maker
makeup
male
mall
man
manage
management
manager
manner
manufacturer
manufacturing
many
map
margin
mark
market
marketing
marriage
married
marry
mask
mass
massive
master
match
material
math
matter
may
maybe
mayor
me
meal
mean
meaning
meanwhile
measure
measurement
meat
mechanism
media
medical
medication
medicine
medium
meet
meeting
member
membership
memory
mental
mention
menu
mere
merely
mess
message
metal
meter
method
Mexican
middle
might
military
milk
million
mind
mine
minister
minor
minority
minute
miracle
mirror
miss
missile
mission
mistake
mix
mixture
mm-hmm
mode
model
moderate
modern
modest
mom
moment
money
monitor
month
mood
moon
moral
more
moreover
morning
mortgage
most
mostly
mother
motion
motivation
motor
mount
mountain
mouse
mouth
move
movement
movie
Mr
Mrs
Ms
much
multiple
murder
muscle
museum
music
musical
musician
Muslim
must
mutual
my
myself
mystery
myth
naked
name
narrative
narrow
nation
national
native
natural
naturally
nature
near
nearby
nearly
necessarily
necessary
neck
need
negative
negotiate
negotiation
neighbor
neighborhood
neither
nerve
nervous
net
network
never
nevertheless
new
newly
news
newspaper
next
nice
night
nine
no
nobody
nod
noise
nomination
none
nonetheless
nor
normal
normally
north
northern
nose
not
note
nothing
notice
notion
novel
now
nowhere
n't
nuclear
number
numerous
nurse
nut
object
objective
obligation
observation
observe
observer
obtain
obvious
obviously
occasion
occasionally
occupation
occupy
occur
ocean
odd
odds
of
off
offense
offensive
offer
office
officer
official
often
oh
oil
ok
okay
old
Olympic
on
once
one
ongoing
onion
online
only
onto
open
opening
operate
operating
operation
operator
opinion
opponent
opportunity
oppose
opposite
opposition
option
or
orange
order
ordinary
organic
organization
organize
orientation
origin
original
originally
other
others
otherwise
ought
our
ourselves
out
outcome
outside
oven
over
overall
overcome
overlook
owe
own
owner
pace
pack
package
page
pain
painful
paint
painter
painting
pair
pale
Palestinian
palm
pan
panel
pant
paper
parent
park
parking
part
participant
participate
participation
particular
particularly
partly
partner
partnership
party
pass
passage
passenger
passion
past
patch
path
patient
pattern
pause
pay
payment
PC
peace
peak
peer
penalty
people
pepper
per
perceive
percentage
perception
perfect
perfectly
perform
performance
perhaps
period
permanent
permission
permit
person
personal
personality
personally
personnel
perspective
persuade
pet
phase
phenomenon
philosophy
phone
photo
photograph
photographer
phrase
physical
physically
physician
piano
pick
picture
pie
piece
pile
pilot
pine
pink
pipe
pitch
place
plan
plane
planet
planning
plant
plastic
plate
platform
play
player
please
pleasure
plenty
plot
plus
PM
pocket
poem
poet
poetry
point
pole
police
policy
political
politically
politician
politics
poll
pollution
pool
poor
pop
popular
population
porch
port
portion
portrait
portray
pose
position
positive
possess
possibility
possible
possibly
post
pot
potato
potential
potentially
pound
pour
poverty
powder
power
powerful
practical
practice
pray
prayer
precisely
predict
prefer
preference
pregnancy
pregnant
preparation
prepare
prescription
presence
present
presentation
preserve
president
presidential
press
pressure
pretend
pretty
prevent
previous
previously
price
pride
priest
primarily
primary
prime
principal
principle
print
prior
priority
prison
prisoner
privacy
private
probably
problem
procedure
proceed
process
produce
producer
product
production
profession
professional
professor
profile
profit
program
progress
project
prominent
promise
promote
prompt
proof
proper
properly
property
proportion
proposal
propose
proposed
prosecutor
prospect
protect
protection
protein
protest
proud
prove
provide
provider
province
provision
psychological
psychologist
psychology
public
publication
publicly
publish
publisher
pull
punishment
purchase
pure
purpose
pursue
push
put
qualify
quality
quarter
quarterback
question
quick
quickly
quiet
quietly
quit
quite
quote
race
racial
radical
radio
rail
rain
raise
range
rank
rapid
rapidly
rare
rarely
rate
rather
rating
ratio
raw
reach
react
reaction
read
reader
reading
ready
real
reality
realize
really
reason
reasonable
recall
receive
recent
recently
recipe
recognition
recognize
recommend
recommendation
record
recording
recover
recovery
recruit
red
reduce
reduction
refer
reference
reflect
reflection
reform
refugee
refuse
regard
regarding
regardless
regime
region
regional
register
regular
regularly
regulate
regulation
reinforce
reject
relate
relation
relationship
relative
relatively
relax
release
relevant
relief
religion
religious
rely
remain
remaining
remarkable
remember
remind
remote
remove
repeat
repeatedly
replace
reply
report
reporter
represent
representation
representative
Republican
reputation
request
require
requirement
research
researcher
resemble
reservation
resident
resist
resistance
resolution
resolve
resort
resource
respect
respond
respondent
response
responsibility
responsible
rest
restaurant
restore
restriction
result
retain
retire
retirement
return
reveal
revenue
review
revolution
rhythm
rice
rich
rid
ride
rifle
right
ring
rise
risk
river
road
rock
role
roll
romantic
roof
room
root
rope
rose
rough
roughly
round
route
routine
row
rub
rule
run
running
rural
rush
Russian
sacred
sad
safe
safety
sake
salad
salary
sale
sales
salt
same
sample
sanction
sand
satellite
satisfaction
satisfy
sauce
save
saving
say
scale
scandal
scared
scenario
scene
schedule
scheme
scholar
scholarship
school
science
scientific
scientist
scope
score
scream
screen
script
sea
search
season
seat
second
secret
secretary
section
sector
secure
security
see
seed
seek
seem
segment
seize
select
selection
self
sell
Senate
senator
send
senior
sense
sensitive
sentence
separate
sequence
series
serious
seriously
serve
service
session
set
setting
settle
settlement
seven
several
severe
sex
sexual
shade
shadow
shake
shall
shape
share
sharp
she
sheet
shelf
shell
shelter
shift
shine
ship
shirt
shit
shock
shoe
shoot
shooting
shop
shopping
shore
short
shortly
shot
should
shoulder
shout
show
shower
shrug
shut
sick
side
sigh
sight
sign
signal
significance
significant
significantly
silence
silent
silver
similar
similarly
simple
simply
sin
since
sing
singer
single
sink
sir
sister
sit
site
situation
six
size
ski
skill
skin
sky
slave
sleep
slice
slide
slight
slightly
slip
slow
slowly
small
smart
smell
smile
smoke
smooth
snap
snow
so
so-called
soccer
social
society
soft
software
soil
solar
soldier
solid
solution
solve
some
somebody
somehow
someone
something
sometimes
somewhat
somewhere
son
song
soon
sophisticated
sorry
sort
soul
sound
soup
source
south
southern
Soviet
space
Spanish
speak
speaker
special
specialist
species
specific
specifically
speech
speed
spend
spending
spin
spirit
spiritual
split
spokesman
sport
spot
spread
spring
square
squeeze
stability
stable
staff
stage
stair
stake
stand
standard
standing
star
stare
start
state
statement
station
statistics
status
stay
steady
steal
steel
step
stick
still
stir
stock
stomach
stone
stop
storage
store
storm
story
straight
strange
stranger
strategic
strategy
stream
street
strength
strengthen
stress
stretch
strike
string
strip
stroke
strong
strongly
structure
struggle
student
studio
study
stuff
stupid
style
subject
submit
subsequent
substance
substantial
succeed
success
successful
successfully
such
sudden
suddenly
sue
suffer
sufficient
sugar
suggest
suggestion
suicide
suit
summer
summit
sun
super
supply
support
supporter
suppose
supposed
Supreme
sure
surely
surface
surgery
surprise
surprised
surprising
surprisingly
surround
survey
survival
survive
survivor
suspect
sustain
swear
sweep
sweet
swim
swing
switch
symbol
symptom
system
table
tablespoon
tactic
tail
take
tale
talent
talk
tall
tank
tap
tape
target
task
taste
tax
taxpayer
tea
teach
teacher
teaching
team
tear
teaspoon
technical
technique
technology
teen
teenager
telephone
telescope
television
tell
temperature
temporary
ten
tend
tendency
tennis
tension
tent
term
terms
terrible
territory
terror
terrorism
terrorist
test
testify
testimony
testing
text
than
thank
thanks
that
the
theater
their
them
theme
themselves
then
theory
therapy
there
therefore
these
they
thick
thin
thing
think
thinking
third
thirty
this
those
though
thought
thousand
threat
threaten
three
throat
through
throughout
throw
thus
ticket
tie
tight
time
tiny
tip
tire
tired
tissue
title
to
tobacco
today
toe
together
tomato
tomorrow
tone
tongue
tonight
too
tool
tooth
top
topic
toss
total
totally
touch
tough
tour
tourist
tournament
toward
towards
tower
town
toy
trace
track
trade
tradition
traditional
traffic
tragedy
trail
train
training
transfer
transform
transformation
transition
translate
transportation
travel
treat
treatment
treaty
tree
tremendous
trend
trial
tribe
trick
trip
troop
trouble
truck
true
truly
trust
truth
try
tube
tunnel
turn
TV
twelve
twenty
twice
twin
two
type
typical
typically
ugly
ultimate
ultimately
unable
uncle
under
undergo
understand
understanding
unfortunately
uniform
union
unique
unit
United
universal
universe
university
unknown
unless
unlike
unlikely
until
unusual
up
upon
upper
urban
urge
us
use
used
useful
user
usual
usually
utility
vacation
valley
valuable
value
variable
variation
variety
various
vary
vast
vegetable
vehicle
venture
version
versus
very
vessel
veteran
via
victim
victory
video
view
viewer
village
violate
violation
violence
violent
virtually
virtue
virus
visible
vision
visit
visitor
visual
vital
voice
volume
volunteer
vote
voter
vs
vulnerable
wage
wait
wake
walk
wall
wander
want
war
warm
warn
warning
wash
waste
watch
water
wave
way
we
weak
wealth
wealthy
weapon
wear
weather
wedding
week
weekend
weekly
weigh
weight
welcome
welfare
well
west
western
wet
what
whatever
wheel
when
whenever
where
whereas
whether
which
while
whisper
white
who
whole
whom
whose
why
wide
widely
widespread
wife
wild
will
willing
win
wind
window
wine
wing
winner
winter
wipe
wire
wisdom
wise
wish
with
withdraw
within
without
witness
woman
wonder
wonderful
wood
wooden
word
work
worker
working
works
workshop
world
worried
worry
worth
would
wound
wrap
write
writer
writing
wrong
yard
yeah
year
yell
yellow
yes
yesterday
yet
yield
you
young
your
yours
yourself
youth
zone
        `;

            function getDictionary() {
                if (_cachedDictionary) {
                    return _cachedDictionary;
                }
                console.log("Parsing dictionary string for the first time...");
                const allWords = dictionaryString
                    .trim()
                    .split(/\s+/)
                    .filter((w) => w.length > 0)
                    .map((w) => w.toLowerCase());
                _cachedDictionary = allWords.filter(
                    (w) => w.length >= 3 && w.length <= 12,
                );
                if (_cachedDictionary.length < 100) {
                    console.warn(
                        "Dictionary has very few valid words (length >= 3 and <= 12).",
                    );
                }
                return _cachedDictionary;
            }

            async function fetchWords(totalWords) {
                setStatus("Parsing local dictionary...", "loading");
                return new Promise((resolve) => {
                    setTimeout(() => {
                        try {
                            const dictionary = getDictionary();
                            if (dictionary.length === 0) {
                                throw new Error(
                                    "No valid words found in the dictionary.",
                                );
                            }

                            const selectedWords = new Set();
                            const maxAttempts = totalWords * 5;
                            let attempts = 0;
                            const dictionaryLength = dictionary.length;

                            while (
                                selectedWords.size < totalWords &&
                                attempts < maxAttempts
                            ) {
                                const randomIndex = Math.floor(
                                    Math.random() * dictionaryLength,
                                );
                                selectedWords.add(dictionary[randomIndex]);
                                attempts++;
                            }

                            let finalWords = Array.from(selectedWords);

                            if (finalWords.length < totalWords) {
                                console.warn(
                                    `Warning: Could not find ${totalWords} unique words. Adding duplicates.`,
                                );
                                setStatus(
                                    "Warning: Not enough unique words. Adding duplicates.",
                                    "loading",
                                );
                                while (finalWords.length < totalWords) {
                                    const randomIndex = Math.floor(
                                        Math.random() * dictionaryLength,
                                    );
                                    finalWords.push(dictionary[randomIndex]);
                                }
                            }
                            resolve(finalWords);
                        } catch (error) {
                            console.error("Dictionary Error:", error);
                            setStatus(
                                `Dictionary Error: ${error.message}`,
                                "error",
                            );
                            setLoadingState(false);
                            resolve(null);
                        }
                    }, 50);
                });
            }

            // --- PUZZLE GENERATION LOGIC ---

            function generateWordSearch(words, gridSize) {
                let puzzleGrid = createEmptyGrid(null, gridSize);
                let solutionGrid = createEmptyGrid(" ", gridSize);
                const placedWords = [];
                const placedWordData = [];

                for (const word of words) {
                    const upperWord = word.toUpperCase();
                    let placed = false;

                    for (let i = 0; i < 100; i++) {
                        const direction =
                            DIRECTIONS[
                                Math.floor(Math.random() * DIRECTIONS.length)
                            ];
                        const startRow = Math.floor(Math.random() * gridSize);
                        const startCol = Math.floor(Math.random() * gridSize);

                        if (
                            canPlaceWord(
                                puzzleGrid,
                                upperWord,
                                startRow,
                                startCol,
                                direction,
                                gridSize,
                            )
                        ) {
                            placeWord(
                                puzzleGrid,
                                solutionGrid,
                                upperWord,
                                startRow,
                                startCol,
                                direction,
                            );
                            placedWords.push(upperWord);

                            const endRow =
                                startRow +
                                (upperWord.length - 1) * direction[0];
                            const endCol =
                                startCol +
                                (upperWord.length - 1) * direction[1];
                            placedWordData.push({
                                r1: startRow,
                                c1: startCol,
                                r2: endRow,
                                c2: endCol,
                            });

                            placed = true;
                            break;
                        }
                    }
                    if (!placed) {
                        console.warn(`Could not place word: ${word}`);
                    }
                }
                fillRandomLetters(puzzleGrid);
                return {
                    puzzleGrid,
                    solutionGrid,
                    wordList: placedWords.sort(),
                    placedWordData,
                };
            }

            function canPlaceWord(grid, word, r, c, dir, gridSize) {
                for (let i = 0; i < word.length; i++) {
                    const newR = r + i * dir[0];
                    const newC = c + i * dir[1];
                    if (
                        newR < 0 ||
                        newR >= gridSize ||
                        newC < 0 ||
                        newC >= gridSize
                    ) {
                        return false;
                    }
                    const existingChar = grid[newR][newC];
                    if (existingChar !== null && existingChar !== word[i]) {
                        return false;
                    }
                }
                return true;
            }

            function placeWord(puzzleGrid, solutionGrid, word, r, c, dir) {
                for (let i = 0; i < word.length; i++) {
                    const newR = r + i * dir[0];
                    const newC = c + i * dir[1];
                    puzzleGrid[newR][newC] = word[i];
                    solutionGrid[newR][newC] = word[i];
                }
            }

            function createEmptyGrid(fillWith, gridSize) {
                return Array(gridSize)
                    .fill(null)
                    .map(() => Array(gridSize).fill(fillWith));
            }

            function fillRandomLetters(grid) {
                const alphabet = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
                const gridSize = grid.length;
                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        if (grid[r][c] === null) {
                            grid[r][c] =
                                alphabet[
                                    Math.floor(Math.random() * alphabet.length)
                                ];
                        }
                    }
                }
            }

            // --- MAZE GENERATION LOGIC ---

            function generateMaze(gridSize) {
                // 1. Create grid
                const mazeGrid = Array(gridSize)
                    .fill(null)
                    .map((_, r) =>
                        Array(gridSize)
                            .fill(null)
                            .map((_, c) => ({
                                r,
                                c,
                                visited: false,
                                walls: { t: true, r: true, b: true, l: true },
                            })),
                    );

                const stack = [];
                let current = mazeGrid[0][0];
                current.visited = true;

                const getUnvisitedNeighbors = (r, c) => {
                    const neighbors = [];
                    if (r > 0 && !mazeGrid[r - 1][c].visited)
                        neighbors.push(mazeGrid[r - 1][c]); // Top
                    if (c < gridSize - 1 && !mazeGrid[r][c + 1].visited)
                        neighbors.push(mazeGrid[r][c + 1]); // Right
                    if (r < gridSize - 1 && !mazeGrid[r + 1][c].visited)
                        neighbors.push(mazeGrid[r + 1][c]); // Bottom
                    if (c > 0 && !mazeGrid[r][c - 1].visited)
                        neighbors.push(mazeGrid[r][c - 1]); // Left
                    return neighbors;
                };

                const removeWalls = (a, b) => {
                    const dr = a.r - b.r;
                    const dc = a.c - b.c;
                    if (dr === 1) {
                        a.walls.t = false;
                        b.walls.b = false;
                    } // a is below b
                    else if (dr === -1) {
                        a.walls.b = false;
                        b.walls.t = false;
                    } // a is above b
                    else if (dc === 1) {
                        a.walls.l = false;
                        b.walls.r = false;
                    } // a is right of b
                    else if (dc === -1) {
                        a.walls.r = false;
                        b.walls.l = false;
                    } // a is left of b
                };

                // 2. Recursive backtracking
                while (true) {
                    const neighbors = getUnvisitedNeighbors(
                        current.r,
                        current.c,
                    );
                    if (neighbors.length > 0) {
                        const chosen =
                            neighbors[
                                Math.floor(Math.random() * neighbors.length)
                            ];
                        stack.push(current);
                        removeWalls(current, chosen);
                        current = chosen;
                        current.visited = true;
                    } else if (stack.length > 0) {
                        current = stack.pop();
                    } else {
                        break; // All cells visited
                    }
                }

                // 3. Add entrance and exit
                mazeGrid[0][0].walls.l = false;
                mazeGrid[gridSize - 1][gridSize - 1].walls.r = false;

                // 4. Find solution path using Breadth-First Search (BFS)
                const solutionPath = findMazeSolution(mazeGrid, gridSize);

                return { mazeGrid, solutionPath, wordList: [] }; // No words for mazes
            }

            function findMazeSolution(mazeGrid, gridSize) {
                const queue = [[[0, 0]]]; // A queue of paths
                const visited = new Set(["0,0"]);
                const endR = gridSize - 1;
                const endC = gridSize - 1;

                while (queue.length > 0) {
                    const path = queue.shift();
                    const [r, c] = path[path.length - 1];

                    if (r === endR && c === endC) {
                        return path; // Found the end!
                    }

                    const cell = mazeGrid[r][c];

                    // Check neighbors
                    // Top
                    if (
                        r > 0 &&
                        !cell.walls.t &&
                        !visited.has(`${r - 1},${c}`)
                    ) {
                        visited.add(`${r - 1},${c}`);
                        queue.push([...path, [r - 1, c]]);
                    }
                    // Right
                    if (
                        c < gridSize - 1 &&
                        !cell.walls.r &&
                        !visited.has(`${r},${c + 1}`)
                    ) {
                        visited.add(`${r},${c + 1}`);
                        queue.push([...path, [r, c + 1]]);
                    }
                    // Bottom
                    if (
                        r < gridSize - 1 &&
                        !cell.walls.b &&
                        !visited.has(`${r + 1},${c}`)
                    ) {
                        visited.add(`${r + 1},${c}`);
                        queue.push([...path, [r + 1, c]]);
                    }
                    // Left
                    if (
                        c > 0 &&
                        !cell.walls.l &&
                        !visited.has(`${r},${c - 1}`)
                    ) {
                        visited.add(`${r},${c - 1}`);
                        queue.push([...path, [r, c - 1]]);
                    }
                }
                return []; // No path found (should be impossible for this algorithm)
            }

            // --- PDF DRAWING LOGIC ---

            /**
             * Draws a single word search answer grid
             */
            function drawWordSearchAnswerGrid(
                doc,
                puzzle,
                boxX,
                boxY,
                boxW,
                boxH,
                title,
            ) {
                const { gridSize, puzzleGrid, placedWordData } = puzzle;
                doc.setFontSize(10);
                doc.setFont("helvetica", "bold");
                doc.text(title, boxX + boxW / 2, boxY, { align: "center" });
                const gridTopY_inBox = boxY + 8;
                const availableGridHeight = boxH - 8;
                doc.setFont("courier", "normal");
                const gridString = Array(gridSize).fill("W").join(" ");
                const scaleFactor = doc.internal.scaleFactor;
                const fontMaxWidth =
                    (boxW * scaleFactor) / doc.getStringUnitWidth(gridString);
                const lineH_at_1pt = 1 * 0.352778 * 1.1;
                const fontMaxHeight =
                    availableGridHeight / (gridSize * lineH_at_1pt);
                let gridFontSize = Math.min(fontMaxWidth, fontMaxHeight);
                gridFontSize = Math.max(2, Math.min(10, gridFontSize));
                doc.setFontSize(gridFontSize);
                const lineH = gridFontSize * 0.352778 * 1.1;
                const gridTextWidth =
                    (doc.getStringUnitWidth(gridString) * gridFontSize) /
                    scaleFactor;
                const gridX_inBox = boxX + (boxW - gridTextWidth) / 2;
                const colWidth =
                    (doc.getStringUnitWidth("W ") * gridFontSize) / scaleFactor;
                const charWidth =
                    (doc.getStringUnitWidth("W") * gridFontSize) / scaleFactor;

                puzzleGrid.forEach((row, r) => {
                    const yPos = gridTopY_inBox + r * lineH;
                    if (yPos < boxY + boxH) {
                        doc.text(row.join(" "), gridX_inBox, yPos);
                    }
                });

                doc.setDrawColor(0, 0, 0);
                doc.setLineWidth(0.3);
                const yOffset = -(gridFontSize * 0.352778 * 0.3);
                const xOffset = charWidth / 2;
                placedWordData.forEach((word) => {
                    const x1 = gridX_inBox + word.c1 * colWidth + xOffset;
                    const y1 = gridTopY_inBox + word.r1 * lineH + yOffset;
                    const x2 = gridX_inBox + word.c2 * colWidth + xOffset;
                    const y2 = gridTopY_inBox + word.r2 * lineH + yOffset;
                    if (y1 < boxY + boxH && y2 < boxY + boxH) {
                        doc.line(x1, y1, x2, y2);
                    }
                });
            }

            /**
             * Draws a single maze (or solution) grid
             */
            function drawMazeGrid(
                doc,
                puzzle,
                boxX,
                boxY,
                boxW,
                boxH,
                title,
                isSolution,
            ) {
                const { gridSize, mazeGrid, solutionPath } = puzzle;
                doc.setFontSize(10);
                doc.setFont("helvetica", "bold");
                doc.text(title, boxX + boxW / 2, boxY, { align: "center" });

                const gridTopY_inBox = boxY + 8;
                const availableGridHeight = boxH - 8;

                // Calculate cell size
                const cellSizeW = boxW / gridSize;
                const cellSizeH = availableGridHeight / gridSize;
                const cellSize = Math.min(cellSizeW, cellSizeH);

                // Center the grid
                const gridTotalW = cellSize * gridSize;
                const gridTotalH = cellSize * gridSize;
                const gridX = boxX + (boxW - gridTotalW) / 2;
                const gridY =
                    gridTopY_inBox + (availableGridHeight - gridTotalH) / 2;

                doc.setDrawColor(0, 0, 0);
                doc.setLineWidth(0.2);

                for (let r = 0; r < gridSize; r++) {
                    for (let c = 0; c < gridSize; c++) {
                        const cell = mazeGrid[r][c];
                        const x = gridX + c * cellSize;
                        const y = gridY + r * cellSize;

                        if (cell.walls.t) doc.line(x, y, x + cellSize, y);
                        if (cell.walls.r)
                            doc.line(
                                x + cellSize,
                                y,
                                x + cellSize,
                                y + cellSize,
                            );
                        if (cell.walls.b)
                            doc.line(
                                x,
                                y + cellSize,
                                x + cellSize,
                                y + cellSize,
                            );
                        if (cell.walls.l) doc.line(x, y, x, y + cellSize);
                    }
                }

                if (isSolution && solutionPath.length > 0) {
                    doc.setDrawColor(255, 0, 0); // Red
                    doc.setLineWidth(cellSize * 0.2); // Make line thick

                    // Use doc.line() for each segment
                    for (let i = 0; i < solutionPath.length - 1; i++) {
                        const [r1, c1] = solutionPath[i];
                        const [r2, c2] = solutionPath[i + 1];

                        const x1 = gridX + (c1 + 0.5) * cellSize;
                        const y1 = gridY + (r1 + 0.5) * cellSize;
                        const x2 = gridX + (c2 + 0.5) * cellSize;
                        const y2 = gridY + (r2 + 0.5) * cellSize;

                        doc.line(x1, y1, x2, y2);
                    }
                }
            }

            async function generatePDF(allPuzzles, pageSize) {
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    format: pageSize,
                    orientation: "portrait",
                });

                const xMargin = 6.35;
                const yMargin = 6.35;
                const pageW = doc.internal.pageSize.getWidth();
                const pageH = doc.internal.pageSize.getHeight();

                const drawWordSearchPage = (puzzle, addPage = true) => {
                    if (addPage) {
                        doc.addPage();
                    }
                    const { gridSize, wordList, puzzleGrid, originalIndex } =
                        puzzle;
                    const availableWidth = pageW - 2 * xMargin;
                    const title = `Word Search Puzzle ${originalIndex + 1} (${puzzle.type})`;
                    let titleTopY = yMargin + 10;
                    doc.setFontSize(18);
                    doc.setFont("helvetica", "bold");
                    doc.text(title, pageW / 2, titleTopY, { align: "center" });
                    const gridTopY = titleTopY + 15;
                    doc.setFont("courier", "normal");
                    const gridString = Array(gridSize).fill("W").join(" ");
                    const scaleFactor = doc.internal.scaleFactor;
                    let availableGridHeight = pageH * 0.6 - gridTopY;
                    const fontMaxWidth =
                        (availableWidth * scaleFactor) /
                        doc.getStringUnitWidth(gridString);
                    const lineH_at_1pt = 1 * 0.352778 * 1.1;
                    const fontMaxHeight =
                        availableGridHeight / (gridSize * lineH_at_1pt);
                    let gridFontSize = Math.min(fontMaxWidth, fontMaxHeight);
                    gridFontSize = Math.max(5, Math.min(16, gridFontSize));
                    doc.setFontSize(gridFontSize);
                    const lineH = gridFontSize * 0.352778 * 1.1;
                    const gridTextWidth =
                        (doc.getStringUnitWidth(gridString) * gridFontSize) /
                        scaleFactor;
                    const gridX =
                        xMargin + (availableWidth - gridTextWidth) / 2;
                    puzzleGrid.forEach((row, r) => {
                        doc.text(row.join(" "), gridX, gridTopY + r * lineH);
                    });
                    doc.setFont("helvetica", "normal");
                    const wordListFontSize = Math.max(8, gridFontSize - 2);
                    doc.setFontSize(wordListFontSize);
                    const wordListLineH = wordListFontSize * 0.352778 * 1.2;
                    const wordListY = pageH * 0.6 + 10;
                    const colCount = 4;
                    const words = wordList;
                    const rowCountPerCol = Math.ceil(words.length / colCount);
                    const colWidth = availableWidth / colCount;
                    words.forEach((word, i) => {
                        const colIndex = Math.floor(i / rowCountPerCol);
                        const rowIndex = i % rowCountPerCol;
                        const x = xMargin + colIndex * colWidth + colWidth / 2;
                        const y = wordListY + rowIndex * wordListLineH;
                        if (y < pageH - yMargin) {
                            doc.text(word, x, y, { align: "center" });
                        }
                    });
                };

                const drawMazePage = (puzzle, addPage = true) => {
                    if (addPage) {
                        doc.addPage();
                    }
                    const { originalIndex } = puzzle;
                    const title = `Maze Puzzle ${originalIndex + 1} (${puzzle.type})`;
                    const boxX = xMargin;
                    const boxY = yMargin;
                    const boxW = pageW - 2 * xMargin;
                    const boxH = pageH - 2 * yMargin;
                    // Draw maze without solution path
                    drawMazeGrid(
                        doc,
                        puzzle,
                        boxX,
                        boxY,
                        boxW,
                        boxH,
                        title,
                        false,
                    );
                };

                // --- 1. Draw all Puzzle Pages ---
                allPuzzles.forEach((puzzle, index) => {
                    if (puzzle.puzzleType === "wordsearch") {
                        drawWordSearchPage(puzzle, index > 0);
                    } else if (puzzle.puzzleType === "maze") {
                        drawMazePage(puzzle, index > 0);
                    }
                });

                // --- 2. Draw all Answer Key Pages ---

                // New rule: <= 30 is 2x2, > 30 is 1x2
                const puzzles2x2 = allPuzzles.filter((p) => p.gridSize <= 30);
                if (puzzles2x2.length > 0) {
                    doc.addPage();
                    doc.setFontSize(22);
                    doc.setFont("helvetica", "bold");
                    doc.text(
                        "Answer Keys (10x10 - 30x30)",
                        pageW / 2,
                        yMargin + 10,
                        { align: "center" },
                    );
                    const mainTitleH = 20;
                    const availableW = pageW - 2 * xMargin;
                    const availableH = pageH - yMargin - mainTitleH;
                    const quadW = availableW / 2;
                    const quadH = availableH / 2;
                    const padding = 5;
                    puzzles2x2.forEach((puzzle, index) => {
                        const gridIndex = index % 4;
                        if (index > 0 && gridIndex === 0) {
                            doc.addPage();
                        }
                        let quadX, quadY;
                        if (gridIndex === 0) {
                            quadX = xMargin;
                            quadY = yMargin + mainTitleH;
                        } else if (gridIndex === 1) {
                            quadX = xMargin + quadW;
                            quadY = yMargin + mainTitleH;
                        } else if (gridIndex === 2) {
                            quadX = xMargin;
                            quadY = yMargin + mainTitleH + quadH;
                        } else {
                            quadX = xMargin + quadW;
                            quadY = yMargin + mainTitleH + quadH;
                        }
                        const boxX = quadX + padding;
                        const boxY = quadY + padding;
                        const boxW = quadW - 2 * padding;
                        const boxH = quadH - 2 * padding;
                        const title = `Puzzle ${puzzle.originalIndex + 1} (${puzzle.type})`;

                        if (puzzle.puzzleType === "wordsearch") {
                            drawWordSearchAnswerGrid(
                                doc,
                                puzzle,
                                boxX,
                                boxY,
                                boxW,
                                boxH,
                                title,
                            );
                        } else if (puzzle.puzzleType === "maze") {
                            drawMazeGrid(
                                doc,
                                puzzle,
                                boxX,
                                boxY,
                                boxW,
                                boxH,
                                title,
                                true,
                            ); // true = draw solution
                        }
                    });
                }

                const puzzles1x2 = allPuzzles.filter((p) => p.gridSize > 30);
                if (puzzles1x2.length > 0) {
                    doc.addPage();
                    doc.setFontSize(22);
                    doc.setFont("helvetica", "bold");
                    doc.text(
                        "Answer Keys (31x31 - 50x50)",
                        pageW / 2,
                        yMargin + 10,
                        { align: "center" },
                    );
                    const mainTitleH = 20;
                    const availableW = pageW - 2 * xMargin;
                    const availableH = pageH - yMargin - mainTitleH;
                    const quadW = availableW;
                    const quadH = availableH / 2;
                    const padding = 5;
                    puzzles1x2.forEach((puzzle, index) => {
                        const gridIndex = index % 2;
                        if (index > 0 && gridIndex === 0) {
                            doc.addPage();
                        }
                        let quadX = xMargin;
                        let quadY =
                            gridIndex === 0
                                ? yMargin + mainTitleH
                                : yMargin + mainTitleH + quadH;
                        const boxX = quadX + padding;
                        const boxY = quadY + padding;
                        const boxW = quadW - 2 * padding;
                        const boxH = quadH - 2 * padding;
                        const title = `Puzzle ${puzzle.originalIndex + 1} (${puzzle.type})`;

                        if (puzzle.puzzleType === "wordsearch") {
                            drawWordSearchAnswerGrid(
                                doc,
                                puzzle,
                                boxX,
                                boxY,
                                boxW,
                                boxH,
                                title,
                            );
                        } else if (puzzle.puzzleType === "maze") {
                            drawMazeGrid(
                                doc,
                                puzzle,
                                boxX,
                                boxY,
                                boxW,
                                boxH,
                                title,
                                true,
                            ); // true = draw solution
                        }
                    });
                }

                doc.save("Word-Search-And-Maze-Puzzles.pdf");
            }

            // --- ZIP/IMAGE DRAWING LOGIC ---

            function drawWordSearchToCanvas(canvas, ctx, puzzle, isSolution) {
                return new Promise((resolve) => {
                    const {
                        gridSize,
                        wordList,
                        puzzleGrid,
                        placedWordData,
                        originalIndex,
                    } = puzzle;

                    const W = 1200;
                    const H = 1500;
                    canvas.width = W;
                    canvas.height = H;
                    ctx.fillStyle = "white";
                    ctx.fillRect(0, 0, W, H);

                    const xMargin = 50;
                    const yMargin = 50;
                    const availableWidth = W - 2 * xMargin;

                    const title = isSolution
                        ? `Answer Key ${originalIndex + 1} (${puzzle.type})`
                        : `Word Search Puzzle ${originalIndex + 1} (${puzzle.type})`;
                    ctx.fillStyle = "black";
                    ctx.font = "bold 48px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText(title, W / 2, yMargin + 48);
                    const gridTopY = yMargin + 100;

                    ctx.font = '10px "Courier New"';
                    const gridString = Array(gridSize).fill("W").join(" ");
                    const textMetrics = ctx.measureText(gridString);
                    const textWidth_at_10px = textMetrics.width;

                    let availableGridHeight = H * 0.6 - gridTopY;
                    if (isSolution) {
                        availableGridHeight = H - gridTopY - yMargin;
                    }

                    const fontMaxWidth =
                        (availableWidth / textWidth_at_10px) * 10;
                    const lineH_at_1px = 1.1;
                    const fontMaxHeight =
                        availableGridHeight / (gridSize * lineH_at_1px);

                    let gridFontSize = Math.min(fontMaxWidth, fontMaxHeight);
                    gridFontSize = Math.max(8, gridFontSize);

                    ctx.font = `bold ${gridFontSize}px "Courier New"`;

                    const lineH = gridFontSize * 1.1;
                    const gridTextWidth = ctx.measureText(gridString).width;
                    const gridX =
                        xMargin + (availableWidth - gridTextWidth) / 2;

                    const colWidth = ctx.measureText("W ").width;
                    const charWidth = ctx.measureText("W").width;

                    ctx.fillStyle = "black";
                    ctx.textAlign = "left";
                    puzzleGrid.forEach((row, r) => {
                        ctx.fillText(
                            row.join(" "),
                            gridX,
                            gridTopY + r * lineH,
                        );
                    });

                    if (isSolution) {
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 3;

                        const yOffset = -(gridFontSize * 0.3);
                        const xOffset = charWidth / 2;

                        placedWordData.forEach((word) => {
                            const x1 = gridX + word.c1 * colWidth + xOffset;
                            const y1 = gridTopY + word.r1 * lineH + yOffset;
                            const x2 = gridX + word.c2 * colWidth + xOffset;
                            const y2 = gridTopY + word.r2 * lineH + yOffset;

                            ctx.beginPath();
                            ctx.moveTo(x1, y1);
                            ctx.lineTo(x2, y2);
                            ctx.stroke();
                        });
                    }

                    if (!isSolution) {
                        ctx.fillStyle = "black";
                        ctx.textAlign = "center";
                        const wordListFontSize = Math.max(
                            16,
                            gridFontSize * 0.8,
                        );
                        ctx.font = `${wordListFontSize}px Arial`;

                        const wordListLineH = wordListFontSize * 1.2;
                        const wordListY = H * 0.6 + 40;

                        const colCount = 4;
                        const words = wordList;
                        const rowCountPerCol = Math.ceil(
                            words.length / colCount,
                        );
                        const colWidth = availableWidth / colCount;

                        words.forEach((word, i) => {
                            const colIndex = Math.floor(i / rowCountPerCol);
                            const rowIndex = i % rowCountPerCol;

                            const x =
                                xMargin + colIndex * colWidth + colWidth / 2;
                            const y = wordListY + rowIndex * wordListLineH;

                            if (y < H - yMargin) {
                                ctx.fillText(word, x, y);
                            }
                        });
                    }

                    resolve();
                });
            }

            function drawMazeToCanvas(canvas, ctx, puzzle, isSolution) {
                return new Promise((resolve) => {
                    const { gridSize, mazeGrid, solutionPath, originalIndex } =
                        puzzle;

                    const W = 1200;
                    const H = 1500;
                    canvas.width = W;
                    canvas.height = H;
                    ctx.fillStyle = "white";
                    ctx.fillRect(0, 0, W, H);

                    const xMargin = 50;
                    const yMargin = 50;
                    const availableWidth = W - 2 * xMargin;
                    const availableHeight = H - 2 * yMargin;

                    const title = isSolution
                        ? `Answer Key ${originalIndex + 1} (${puzzle.type})`
                        : `Maze Puzzle ${originalIndex + 1} (${puzzle.type})`;
                    ctx.fillStyle = "black";
                    ctx.font = "bold 48px Arial";
                    ctx.textAlign = "center";
                    ctx.fillText(title, W / 2, yMargin + 48);

                    const gridTopY = yMargin + 100;
                    const availableGridHeight = H - gridTopY - yMargin;

                    const cellSizeW = availableWidth / gridSize;
                    const cellSizeH = availableGridHeight / gridSize;
                    const cellSize = Math.min(cellSizeW, cellSizeH);

                    const gridTotalW = cellSize * gridSize;
                    const gridTotalH = cellSize * gridSize;
                    const gridX = xMargin + (availableWidth - gridTotalW) / 2;
                    const gridY =
                        gridTopY + (availableGridHeight - gridTotalH) / 2;

                    ctx.strokeStyle = "black";
                    ctx.lineWidth = 2;

                    for (let r = 0; r < gridSize; r++) {
                        for (let c = 0; c < gridSize; c++) {
                            const cell = mazeGrid[r][c];
                            const x = gridX + c * cellSize;
                            const y = gridY + r * cellSize;

                            ctx.beginPath();
                            if (cell.walls.t) {
                                ctx.moveTo(x, y);
                                ctx.lineTo(x + cellSize, y);
                            }
                            if (cell.walls.r) {
                                ctx.moveTo(x + cellSize, y);
                                ctx.lineTo(x + cellSize, y + cellSize);
                            }
                            if (cell.walls.b) {
                                ctx.moveTo(x, y + cellSize);
                                ctx.lineTo(x + cellSize, y + cellSize);
                            }
                            if (cell.walls.l) {
                                ctx.moveTo(x, y);
                                ctx.lineTo(x, y + cellSize);
                            }
                            ctx.stroke();
                        }
                    }

                    if (isSolution && solutionPath.length > 0) {
                        ctx.strokeStyle = "red";
                        ctx.lineWidth = cellSize * 0.3;
                        ctx.lineCap = "round";
                        ctx.lineJoin = "round";

                        ctx.beginPath();
                        const start = solutionPath[0];
                        const startX = gridX + (start[1] + 0.5) * cellSize;
                        const startY = gridY + (start[0] + 0.5) * cellSize;
                        ctx.moveTo(startX, startY);

                        for (let i = 1; i < solutionPath.length; i++) {
                            const [r, c] = solutionPath[i];
                            const x = gridX + (c + 0.5) * cellSize;
                            const y = gridY + (r + 0.5) * cellSize;
                            ctx.lineTo(x, y);
                        }
                        ctx.stroke();
                    }

                    resolve();
                });
            }

            /**
             * Generates a ZIP file with all puzzles and answers as images
             */
            async function generateZIP(allPuzzles) {
                const zip = new JSZip();
                const puzzleFolder = zip.folder("Puzzles");
                const answerFolder = zip.folder("AnswerKeys");

                // Create one canvas to reuse
                const canvas = document.createElement("canvas");
                const ctx = canvas.getContext("2d");

                for (let i = 0; i < allPuzzles.length; i++) {
                    const puzzle = allPuzzles[i];
                    const index = puzzle.originalIndex;

                    setStatus(
                        `Generating image ${i * 2 + 1} of ${allPuzzles.length * 2}...`,
                        "loading",
                    );

                    // 1. Draw and add puzzle
                    if (puzzle.puzzleType === "wordsearch") {
                        await drawWordSearchToCanvas(
                            canvas,
                            ctx,
                            puzzle,
                            false,
                        );
                    } else {
                        await drawMazeToCanvas(canvas, ctx, puzzle, false);
                    }
                    const puzzleBlob = await new Promise((resolve) =>
                        canvas.toBlob(resolve, "image/png"),
                    );
                    puzzleFolder.file(
                        `Puzzle_${index + 1}_(${puzzle.type}).png`,
                        puzzleBlob,
                    );

                    setStatus(
                        `Generating image ${i * 2 + 2} of ${allPuzzles.length * 2}...`,
                        "loading",
                    );

                    // 2. Draw and add answer key
                    if (puzzle.puzzleType === "wordsearch") {
                        await drawWordSearchToCanvas(canvas, ctx, puzzle, true);
                    } else {
                        await drawMazeToCanvas(canvas, ctx, puzzle, true);
                    }
                    const answerBlob = await new Promise((resolve) =>
                        canvas.toBlob(resolve, "image/png"),
                    );
                    answerFolder.file(
                        `AnswerKey_${index + 1}_(${puzzle.type}).png`,
                        answerBlob,
                    );
                }

                setStatus("Compressing ZIP file...", "loading");
                const content = await zip.generateAsync({ type: "blob" });

                // Trigger download
                const link = document.createElement("a");
                link.href = URL.createObjectURL(content);
                link.download = "Puzzles-And-Mazes.zip";
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            }

            /**
             * Sets the loading state of the UI
             */
            function setLoadingState(isLoading) {
                generateBtn.disabled = isLoading;
                addBatchBtn.disabled = isLoading;
                clearBatchesBtn.disabled = isLoading;

                if (isLoading) {
                    generateBtn.textContent = "Generating...";
                } else {
                    generateBtn.textContent = "Generate";
                    updateCounter(); // Re-check button state
                }
            }

            /**
             * Updates the status message
             */
            function setStatus(message, type = "normal") {
                statusEl.textContent = message;
                statusEl.classList.remove(
                    "text-gray-500",
                    "text-red-600",
                    "text-green-600",
                );

                switch (type) {
                    case "error":
                        statusEl.classList.add("text-red-600");
                        break;
                    case "success":
                        statusEl.classList.add("text-green-600");
                        break;
                    case "loading":
                    case "normal":
                    default:
                        statusEl.classList.add("text-gray-500");
                        break;
                }
            }
        </script>
    </body>
</html>
